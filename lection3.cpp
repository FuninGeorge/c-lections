
// #include <mm_malloc.h>
// #include <new>
//
//  Created by Георгий Фунин on 06.04.2024.
//

//================================================================================================================//
/*
 * первые 20 минут лекции-организационные вопросы(отвечать на комментарии проверяющим, только 50 человек отправило
 * первую лабу и тд...)
 *
 */
//================================================================================================================//

//
//
//                                        перегрузка операторов

struct B
{
	int x, y;

	B operator+(const B &z) const;

	B &operator+=(const B &z);
};

B B::operator+(const B &z) const
{	 //<-дописал после (1) ключевое слово const
	B res = *this;
	res += z;
	return res;
}

B &B::operator+=(const B &z)
{	 // амперсанд & нужен для передачи ссылки, а не указателя, это лучше
	x += z.x;
	y += z.y;
	return *this;
}
// const B c={1,1},d={2,2}
// B c = c+d - не скомпилится, т.к. наш метод не константный, т.к. *this не константный  (1)

/*
 * для логических операторов &&, || перегрузка операторов не работает, т.к. перегрузка операторов - просто вызов
 * функции.
 *
 */

//================================================================================================================//
/*
 * операторы бывают двух типов - внешние и внутренние
 *
 * некоторые можно написать только во внешней, некоторые только во внутренней
 *
 */

// здесь оба аргумента объявлены явно, в отличие от предыдущей реализации, где второй аргумент уходил в неявный this
B operator+(const B &z, const B &w)
{
	B res = w;
	res += z;
	return res;
}

// еще одна реализация внешнего оператора сложения

B operator+(B w, const B &z)
{
	w += z;
	return w;
	// NB: return w+=z; тоже работает
}

//================================================================================================================//

class C
{	 // единственная разница между структурой и классом-по умолчанию в классах видимость private, в структурах-puclic
  private:
	int x, y;	 // эти поля снаружи структуры видны не будут

  public:
	B operator+(const B &z) const;

	B &operator+=(const B &z);

	C()
	{
		x = 0;
		y = 0;
	}

	//    C(int a, int b) {
	//        x = a;
	//        y = b;
	//    }

	C(int a, int b) :
		x(a), y(b) {}	 // настоящая инициализация(???), инициализирующая соответствующие поля аргументами конструктора
};

/*
 * конструкторы и деструкторы - это такие специальные функции, обладающие следующими свойствами:
 * 1) название с большой буквы, совпадает с названием класса
 * 2) не имеет возвращаемого значения, даже void
 * он вызывается всегда автоматически при создании объекта этого класса
 *
 * B obj; - вызывается здесь
 *
 * есть конструктор по умолчанию, если мы не создали свой(практически бесполезен)
 *
 * конструкторы, как и методы, могут быть перегружены
 *
 * конструкторы могут иметь аргументы по умолчанию
 *
 * A(int a=0,int b=0){x=a;y=b}
 *
 * конструктору можно передавать аргументы через фигурные скобки
 *
 */

B b;	// компилятся обе строчки, все хорошо
B c(1, 2);

// NB:конструкторы могут быть приватными, то есть создать объекты такого типа будет нельзя

//================================================================================================================//
/*
 * что такое деструктор?
 * особая функция, имеющая название ~(название класса), не принимающая аргументы
 * необходима для освобождения ресурса
 * вызывается, когда объект умирает
 * Сначала, делает то, что мы его просим, потом вызывает деструкторы полей класса
 *
 *
 * NB:конструктор и деструктор не выделяют память и не удаляют ее
 */
//================================================================================================================//
/*
 *                                 динамическое выделение памяти
 *
 *
 */

int main()
{
	C *p = new C(1, 2);	   // new - комбинация динамического выделения памяти и вызова конструктора

	delete p;	 // обязательно использовать delete, если создавал с new
	C *r = new C[5];	// это другой оператор new !!!, квадратные скобки относятся к слову new
	delete[] r;	   //-использовать тот же delete, что и new
	//    C *e = malloc(sizeof(C)); -аналог создания объекта (нужно подключение хидера new)
	//  new(e) C(1,2);
	// P.S. какая-то хуета
	// C *z = new(std::notthrow) A;
}
//================================================================================================================//
/*

*/
